/* ========================================================================
   $File: $
   $Date: $
   $Revision: $
   $Creator: Milad Khodabandeh $
   $Notice: (C) Copyright 2024 by Milad Khodabandeh. All Rights Reserved. $
   ======================================================================== */

#define UNICODE


#include <strsafe.h>
#include <Windows.h>
#include <UIAutomation.h>
#include <shellapi.h>
#include <objbase.h>
#include "win32_cursor.h"
#include <UIAutomation.h>
#include <oleauto.h>

global_variable bool32 Running;



void DebugFormattedW(const wchar_t* name, int value)
{
    wchar_t buf[256];
    StringCchPrintfW(buf, 256, L"Name: %s, Value: %d", name, value);
    OutputDebugStringW(buf);
}


class NewWindowAutomationHandler : public IUIAutomationEventHandler
{
    public:
    // IUnknown
    ULONG STDMETHODCALLTYPE AddRef() override 
    {
        return static_cast<ULONG>(InterlockedIncrement(&_refCount));
    }
    
    ULONG STDMETHODCALLTYPE Release() override 
    {
        ULONG val = static_cast<ULONG>(InterlockedDecrement(&_refCount));
        if (val == 0) delete this;
        return val;
    }
    
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, void** ppvObject) override 
    {
        if (riid == __uuidof(IUnknown) || riid == __uuidof(IUIAutomationEventHandler)) 
        {
            *ppvObject = static_cast<IUIAutomationEventHandler*>(this);
            AddRef();
            return S_OK;
        }
        *ppvObject = nullptr;
        return E_NOINTERFACE;
    }
    
    // IUIAutomationEventHandler
    HRESULT STDMETHODCALLTYPE HandleAutomationEvent(IUIAutomationElement* sender, EVENTID eventId) override 
    {
        BSTR name = nullptr;
        if (sender) {
            if (SUCCEEDED(sender->get_CurrentName(&name)) && name) 
            {
                // (use name if you need it)
                //OutputDebugString(name);
                DebugFormattedW(name, (int)eventId);
                OutputDebugString(TEXT("\n"));
                SysFreeString(name);
            }
        }
        return S_OK;
    }
    
    protected:
    // Virtual dtor fixes the warnings and is standard for COM objects with virtual methods.
    virtual ~NewWindowAutomationHandler() = default;
    
    private:
    volatile LONG _refCount = 1; // Interlocked* expects (volatile) LONG*
};


LRESULT CALLBACK MainWindowCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    switch (uMsg)
    {
        case WM_USER + 100:
        
        /*
        LOWORD(lParam) contains notification events, such as NIN_BALLOONSHOW, NIN_POPUPOPEN, or WM_CONTEXTMENU.
            HIWORD(lParam) contains the icon ID. Icon IDs are restricted to a length of 16 bits.
            GET_X_LPARAM(wParam) returns the X anchor coordinate for notification events NIN_POPUPOPEN, NIN_SELECT, NIN_KEYSELECT, and all mouse messages between WM_MOUSEFIRST and WM_MOUSELAST. If any of those messages are generated by the keyboard, wParam is set to the upper-left corner of the target icon. For all other messages, wParam is undefined.
            GET_Y_LPARAM(wParam) returns the Y anchor coordinate for notification events and messages as defined for the X anchor.
            */
        
        switch(LOWORD(lParam))
        {
            case WM_CONTEXTMENU:
            case WM_RBUTTONUP:
            OutputDebugString(TEXT("right click /n"));
            break;
            default:
        }
        break;
        default:
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR lpCmdLine, int nCmdShow)
{
    //check if another instance is running, if yes, quit, show a dialog and return 0
    
    HANDLE InstanceMutexHandle;
    
    CreateMutexW(nullptr,
                 TRUE,
                 TEXT("ChaseTheCursorSingletonMutex")
                 );
    
    if(GetLastError() == ERROR_ALREADY_EXISTS )
    {
        MessageBox(
                   nullptr,
                   TEXT("Another instance of this program is already running!"),
                   nullptr,
                   MB_OK
                   );
        return 0;
    }
    
    WNDCLASSEX WindowClass {};
    WindowClass.style = CS_OWNDC;
    WindowClass.lpfnWndProc = MainWindowCallback;
    WindowClass.lpszClassName = TEXT("ChaseTheCursorWindowClass");
    WindowClass.cbSize = sizeof(WNDCLASSEX);
    
    if(RegisterClassEx(&WindowClass))
    {
        HWND WindowHandle = CreateWindowEx(
                                           0,                              // Optional window styles.
                                           WindowClass.lpszClassName,      // Window class
                                           TEXT("ChaseTheCursor"),         // Window text
                                           0,                              // Window style
                                           // Size and position
                                           0, 0, 0, 0,
                                           
                                           HWND_MESSAGE,  // Parent window    
                                           nullptr,       // Menu
                                           hInstance,     // Instance handle
                                           nullptr        // Additional application data
                                           );
        
        if (WindowHandle == nullptr)
        {
            return 0;
        }
        
        // {8EA2A47B-F95F-42CF-9CF5-B952DD57E661}
        static const GUID TrayIconGUID = 
        { 0x8ea2a47b, 0xf95f, 0x42cf, { 0x9c, 0xf5, 0xb9, 0x52, 0xdd, 0x57, 0xe6, 0x61 } };
        
        NOTIFYICONDATAW Nid {};
        Nid.hWnd = WindowHandle;
        Nid.guidItem = TrayIconGUID;
        Nid.cbSize = sizeof(NOTIFYICONDATA);
        wcscpy_s(Nid.szTip, L"Chase the Cursor");
        Nid.uFlags = NIF_GUID | NIF_MESSAGE | NIF_TIP;
        Nid.uCallbackMessage = WM_USER + 100;
        
        if(Shell_NotifyIcon(NIM_ADD, &Nid))
        {
            
            NOTIFYICONIDENTIFIER Nii {};
            
            Nii.cbSize = sizeof(NOTIFYICONIDENTIFIER);
            Nii.hWnd = WindowHandle;
            Nii.guidItem = TrayIconGUID;
            
            RECT TrayIconLocation {};
            
            if(SUCCEEDED(Shell_NotifyIconGetRect(&Nii,&TrayIconLocation)))
            {
                HRESULT hr = CoInitializeEx(nullptr, COINIT_MULTITHREADED);
                if (FAILED(hr)) {
                    wprintf(L"CoInitializeEx failed: 0x%08X\n", hr);
                    return 1;
                }
                
                
                //initing the Automation Client Interface
                IUIAutomation *g_pAutomation {};
                hr = CoCreateInstance(__uuidof(CUIAutomation), nullptr, CLSCTX_INPROC_SERVER, 
                                      __uuidof(IUIAutomation), (void**)&g_pAutomation);
                
                if (FAILED(hr)) {
                    wprintf(L"CoCreateInstance failed: 0x%08X\n", hr);
                    CoUninitialize();
                    return 1;
                }
                
                if(SUCCEEDED(hr))
                {
                    // UI Element that we want info from: Desktop
                    IUIAutomationElement *DesktopElement;
                    hr = g_pAutomation->GetRootElement(&DesktopElement);
                    
                    
                    if (FAILED(hr) || !DesktopElement) {
                        wprintf(L"GetRootElement failed: 0x%08X\n", hr);
                        g_pAutomation->Release();
                        CoUninitialize();
                        return 1;
                    }
                    NewWindowAutomationHandler* handler = new NewWindowAutomationHandler();
                    
                    hr = g_pAutomation->AddAutomationEventHandler(UIA_Window_WindowOpenedEventId,
                                                                  DesktopElement,
                                                                  TreeScope_Children,
                                                                  nullptr, // [in] IUIAutomationCacheRequest *cacheRequest, A pointer to a cache request, or NULL if no caching is wanted.
                                                                  handler);
                }
                
                
                Running = true;
                while(Running)
                {
                    MSG Message;
                    while(PeekMessage(&Message,nullptr,0,0, PM_REMOVE))
                    {
                        if(Message.message == WM_QUIT)
                        {
                            Running = false;
                        }
                        
                        TranslateMessage(&Message);
                        DispatchMessage(&Message);
                    }
                }
            }
        }
        else
        {
            return 0;
        }
    }
}
