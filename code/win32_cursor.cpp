/* ========================================================================
   $File: $
   $Date: $
   $Revision: $
   $Creator: Milad Khodabandeh $
   $Notice: (C) Copyright 2024 by Milad Khodabandeh. All Rights Reserved. $
   ======================================================================== */

#define UNICODE


#include <strsafe.h>
#include <Windows.h>
#include <UIAutomation.h>
#include <shellapi.h>
#include <objbase.h>
#include "win32_cursor.h"
#include <UIAutomation.h>
#include <oleauto.h>
#include <dwmapi.h>
#include <cmath>

global_variable bool32 Running;
global_variable UINT g_msgShellHook {};



internal RECT GetWorkRectFromMonitor(HMONITOR hmon) {
    MONITORINFOEX mi{};
    mi.cbSize = sizeof(mi);
    GetMonitorInfo(hmon, &mi);
    return mi.rcWork; // use work area (respects taskbar, orientation)
}

internal bool IsEffectivelyZeroSize(const RECT& r) {
    return (r.right - r.left) <= 1 || (r.bottom - r.top) <= 1;
}

internal void MoveWindowPreservingRelativePosition_NoResize(HWND hwnd, HMONITOR hmonDst) {
    if (!IsWindow(hwnd)) return;
    
    // Ignore child/tool windows and invisible shells (optional but reduces noise)
    LONG_PTR style = GetWindowLongPtr(hwnd, GWL_STYLE);
    if (style & WS_CHILD) return;
    
    // Source/dest monitors
    HMONITOR hmonSrc = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
    RECT rws = GetWorkRectFromMonitor(hmonSrc);
    RECT rwd = GetWorkRectFromMonitor(hmonDst);
    
    // Current outer rect (in screen coords)
    RECT w; 
    if (!GetWindowRect(hwnd, &w)) return;
    
    // If zero-sized/placeholder (common during creation), bail
    if (IsEffectivelyZeroSize(w)) return;
    
    // If maximized, restore → move → re-maximize (feels natural across monitors)
    bool wasMaximized = (style & WS_MAXIMIZE) != 0;
    if (wasMaximized) ShowWindow(hwnd, SW_RESTORE);
    
    // Use the window *center* as anchor for relative mapping
    const double cx = 0.5 * (double(w.left) + double(w.right));
    const double cy = 0.5 * (double(w.top)  + double(w.bottom));
    const double rw = double(rws.right  - rws.left);
    const double rh = double(rws.bottom - rws.top);
    
    // Relative (0..1), clamped to guard partially off-screen windows
    double rx = rw > 0 ? (cx - rws.left) / rw : 0.5;
    double ry = rh > 0 ? (cy - rws.top ) / rh : 0.5;
    rx = max(0.0, min(1.0, rx));
    ry = max(0.0, min(1.0, ry));
    
    // Map to destination work area
    const double dw = double(rwd.right  - rwd.left);
    const double dh = double(rwd.bottom - rwd.top);
    const double cxp = rwd.left + rx * dw;
    const double cyp = rwd.top  + ry * dh;
    
    const int ww = (w.right - w.left);
    const int hh = (w.bottom - w.top);
    
    int newLeft = (int)llround(cxp - ww * 0.5);
    int newTop  = (int)llround(cyp - hh * 0.5);
    
    // Clamp fully inside destination work area
    newLeft = max(rwd.left,  min(newLeft, rwd.right  - ww));
    newTop  = max(rwd.top,   min(newTop,  rwd.bottom - hh));
    
    SetWindowPos(hwnd, nullptr, newLeft, newTop, 0, 0,
                 SWP_NOZORDER | SWP_NOACTIVATE | SWP_NOSIZE);
    
    if (wasMaximized) ShowWindow(hwnd, SW_MAXIMIZE);
}


internal void DebugFormattedW(const wchar_t* name, int value)
{
    wchar_t buf[256];
    StringCchPrintfW(buf, 256, L"Name: %s, Value: %d", name, value);
    OutputDebugStringW(buf);
}

void MoveToMouseMonitor(HWND WindowHandle) 
{
    POINT mouse {};
    if (!GetCursorPos(&mouse)) return;
    
    HMONITOR hmonDst = MonitorFromPoint(mouse, MONITOR_DEFAULTTONEAREST);
    if (!hmonDst) return;
    
    MoveWindowPreservingRelativePosition_NoResize(WindowHandle, hmonDst);
}



LRESULT CALLBACK MainWindowCallback(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) 
{
    switch (uMsg)
    {
        case WM_USER + 100:
        
        /*
        LOWORD(lParam) contains notification events, such as NIN_BALLOONSHOW, NIN_POPUPOPEN, or WM_CONTEXTMENU.
            HIWORD(lParam) contains the icon ID. Icon IDs are restricted to a length of 16 bits.
            GET_X_LPARAM(wParam) returns the X anchor coordinate for notification events NIN_POPUPOPEN, NIN_SELECT, NIN_KEYSELECT, and all mouse messages between WM_MOUSEFIRST and WM_MOUSELAST. If any of those messages are generated by the keyboard, wParam is set to the upper-left corner of the target icon. For all other messages, wParam is undefined.
            GET_Y_LPARAM(wParam) returns the Y anchor coordinate for notification events and messages as defined for the X anchor.
            */
        
        switch(LOWORD(lParam))
        {
            case WM_CONTEXTMENU:
            case WM_RBUTTONUP:
            OutputDebugString(TEXT("right click /n"));
            break;
            default:
        }
        break;
        default:
    }
    
    if (uMsg == g_msgShellHook)
    {
        switch (wParam)
        {
            case HSHELL_WINDOWCREATED:
            OutputDebugString(TEXT("new window is created! \n"));
            MoveToMouseMonitor((HWND)lParam);
            break;
            default:
        }
    }
    return DefWindowProc(hwnd, uMsg, wParam, lParam);
}

int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   PSTR lpCmdLine, int nCmdShow)
{
    //check if another instance is running, if yes, quit, show a dialog and return 0
    
    HANDLE InstanceMutexHandle;
    
    CreateMutexW(nullptr,
                 TRUE,
                 TEXT("ChaseTheCursorSingletonMutex")
                 );
    
    if(GetLastError() == ERROR_ALREADY_EXISTS )
    {
        MessageBox(
                   nullptr,
                   TEXT("Another instance of this program is already running!"),
                   nullptr,
                   MB_OK
                   );
        return 0;
    }
    
    WNDCLASSEX WindowClass {};
    WindowClass.style = CS_OWNDC;
    WindowClass.lpfnWndProc = MainWindowCallback;
    WindowClass.lpszClassName = TEXT("ChaseTheCursorWindowClass");
    WindowClass.cbSize = sizeof(WNDCLASSEX);
    
    if(RegisterClassEx(&WindowClass))
    {
        HWND WindowHandle = CreateWindowEx(
                                           0,                              // Optional window styles.
                                           WindowClass.lpszClassName,      // Window class
                                           TEXT("ChaseTheCursor"),         // Window text
                                           0,                              // Window style
                                           // Size and position
                                           0, 0, 0, 0,
                                           
                                           HWND_MESSAGE,  // Parent window    
                                           nullptr,       // Menu
                                           hInstance,     // Instance handle
                                           nullptr        // Additional application data
                                           );
        
        if (WindowHandle == nullptr)
        {
            return 0;
        }
        
        // {8EA2A47B-F95F-42CF-9CF5-B952DD57E661}
        static const GUID TrayIconGUID = 
        { 0x8ea2a47b, 0xf95f, 0x42cf, { 0x9c, 0xf5, 0xb9, 0x52, 0xdd, 0x57, 0xe6, 0x61 } };
        
        NOTIFYICONDATAW Nid {};
        Nid.hWnd = WindowHandle;
        Nid.guidItem = TrayIconGUID;
        Nid.cbSize = sizeof(NOTIFYICONDATA);
        wcscpy_s(Nid.szTip, L"Chase the Cursor");
        Nid.uFlags = NIF_GUID | NIF_MESSAGE | NIF_TIP;
        Nid.uCallbackMessage = WM_USER + 100;
        
        if(Shell_NotifyIcon(NIM_ADD, &Nid))
        {
            
            NOTIFYICONIDENTIFIER Nii {};
            
            Nii.cbSize = sizeof(NOTIFYICONIDENTIFIER);
            Nii.hWnd = WindowHandle;
            Nii.guidItem = TrayIconGUID;
            
            RECT TrayIconLocation {};
            
            if(SUCCEEDED(Shell_NotifyIconGetRect(&Nii,&TrayIconLocation)))
            {
                HRESULT hr = CoInitializeEx(nullptr, COINIT_MULTITHREADED);
                if (FAILED(hr)) {
                    wprintf(L"CoInitializeEx failed: 0x%08X\n", hr);
                    return 1;
                }
                
                g_msgShellHook = RegisterWindowMessage(L"SHELLHOOK");
                RegisterShellHookWindow(WindowHandle);
                
                Running = true;
                while(Running)
                {
                    MSG Message;
                    while(PeekMessage(&Message,nullptr,0,0, PM_REMOVE))
                    {
                        if(Message.message == WM_QUIT)
                        {
                            Running = false;
                        }
                        
                        TranslateMessage(&Message);
                        DispatchMessage(&Message);
                    }
                }
            }
        }
        else
        {
            return 0;
        }
    }
}
